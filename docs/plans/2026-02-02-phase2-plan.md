# MiniClaw Phase 2 实施计划

> 目标：多步工具调用，完整 ReAct 循环，HITL 人工确认

## 概览

| 编号 | 模块 | 主题 | 预估时间 |
|------|------|------|----------|
| P2-01 | tools | Tool 模型与 ToolRegistry | 30-60 min |
| P2-02 | llm | Function Calling 支持 | 30-60 min |
| P2-03 | tools | 内置工具 read_file / write_file | 30-60 min |
| P2-04a | tools | 内置工具 http_get / shell | 30-60 min |
| P2-04b | tools | Shell 异步执行与流式输出 | 30-60 min |
| P2-05 | tools | ToolDispatcher 调度器 | 30-60 min |
| P2-06 | runtime | AgentRuntime ReAct 单步 | 30-60 min |
| P2-07 | runtime | ReAct 多步循环与防护 | 30-60 min |
| P2-08 | gateway | tool.call / tool.result 事件 | 30-60 min |
| P2-09 | tools | HITL 确认机制 | 30-60 min |
| P2-10 | ui | Vue 工具调用可视化 | 30-60 min |

## 核心设计决策

| 决策点 | 选择 | 理由 |
|--------|------|------|
| 工具调用方式 | OpenAI Function Calling | 行业标准，结构化可靠，Ollama/DeepSeek/通义都支持 |
| HITL 阻塞机制 | Reactor Mono.create + Sink | 响应式一致性，不阻塞线程，生产级方案 |

## Git Commit 规范

格式：`<type>(<scope>): [P2-XX] <description>`

示例：
- `feat(tools): [P2-01] Tool 模型与 ToolRegistry`
- `feat(llm): [P2-02] Function Calling 支持`
- `feat(runtime): [P2-06] AgentRuntime ReAct 单步`

## 前置条件

- Phase 1 全部完成
- 理解 OpenAI Function Calling 协议格式
- 理解 ReAct 循环概念（Think → Act → Observe → Loop）

---

## P2-01：Tool 模型与 ToolRegistry

`feat(tools): [P2-01] Tool 模型与 ToolRegistry`

### 任务清单

- [ ] ToolDefinition 模型
  - name：工具名称
  - description：工具描述（给 LLM 看）
  - parameters：JSON Schema 格式的参数定义
  - hitl：是否需要人工确认（默认 false）
- [ ] Tool 接口定义
  ```java
  public interface Tool {
      ToolDefinition getDefinition();
      Mono<ToolResult> execute(Map<String, Object> arguments);
  }
  ```
- [ ] ToolResult 模型（success/error + content）
- [ ] ToolRegistry 组件
  - register(Tool)：注册工具
  - get(name)：按名称获取
  - list()：列出所有工具定义（供 LLM 使用）
- [ ] 自动注册机制（Spring @Component 扫描）

### 知识点

- JSON Schema 基础
- 注册表模式（Registry Pattern）
- Spring Bean 自动发现

### 验收标准

- ToolRegistry 能注册和列出工具
- 工具定义能序列化为 OpenAI tools 格式

---

## P2-02：Function Calling 支持

`feat(llm): [P2-02] Function Calling 支持`

### 任务清单

- [ ] LlmRequest 扩展
  - 添加 tools 字段（List<ToolDefinition>）
  - 添加 tool_choice 字段（auto/none/specific）
- [ ] LlmResponse / LlmChunk 扩展
  - 添加 tool_calls 字段
  - ToolCall 模型：id, name, arguments
- [ ] OpenAiCompatibleLlmClient 修改
  - 请求体加入 tools 数组
  - 解析响应中的 tool_calls
  - 流式模式下累积 tool_calls delta
- [ ] 处理 finish_reason: "tool_calls"

### 知识点

- OpenAI Function Calling 协议
- 流式响应中 tool_calls 的增量解析
- finish_reason 语义

### 验收标准

- 发送带 tools 的请求，LLM 返回 tool_calls
- 流式模式下能正确累积解析 tool_calls
- 编写测试：问"北京天气"，配置 get_weather 工具，LLM 应返回 tool_calls

---

## P2-03：内置工具 read_file / write_file

`feat(tools): [P2-03] 内置工具 read_file / write_file`

### 任务清单

- [ ] ReadFileTool 实现
  - 参数：path (string, required)
  - 返回：文件内容或错误信息
  - 安全：限制在 workspace 目录内
  - hitl: false
- [ ] WriteFileTool 实现
  - 参数：path (string), content (string)
  - 返回：写入成功/失败
  - 安全：限制在 workspace 目录内
  - hitl: true（写操作需确认）
- [ ] JSON Schema 定义
- [ ] 注册到 ToolRegistry

### 知识点

- 文件 I/O 操作
- 路径安全校验（防止目录穿越）
- JSON Schema 参数定义

### 验收标准

- ReadFileTool 能读取 workspace 内文件
- WriteFileTool 能写入文件
- 尝试读取 workspace 外文件返回错误

---

## P2-04a：内置工具 http_get / shell

`feat(tools): [P2-04a] 内置工具 http_get / shell`

### 任务清单

- [ ] HttpGetTool 实现
  - 参数：url (string)
  - 返回：响应体（截断过长内容）
  - hitl: false
- [ ] ShellTool 实现
  - 参数：command (string)
  - 返回：stdout + stderr
  - 超时控制（Future.get + destroyForcibly）
  - 跨平台：Windows cmd.exe / Linux sh
  - hitl: true（命令执行需确认）
- [ ] JSON Schema 定义
- [ ] 注册到 ToolRegistry

### 知识点

- WebClient HTTP 请求
- ProcessBuilder 进程执行
- 跨平台适配（Windows GBK / Linux UTF-8）
- Future 超时控制与资源清理

### 验收标准

- HttpGetTool 能获取网页内容
- ShellTool 能执行简单命令（如 `ls`, `dir`）
- ShellTool 超时能正确终止进程

---

## P2-04b：Shell 异步执行与流式输出

`feat(tools): [P2-04b] Shell 异步执行与流式输出`

### 设计动机

现有 ShellTool 是同步阻塞的，适合快速命令（ls、cat）。但真实 Agent 场景需要执行长时间命令（docker-compose up、npm install、编译构建等），Agent 需要：
1. 启动命令后不阻塞
2. 定期查看输出，判断进程状态
3. 发现错误后自主决定终止或重试

这是 Agent 能力的核心亮点——让 AI 自己操作环境、排查问题。

### 任务清单

- [ ] ProcessManager 组件
  - 管理所有异步进程：Map<processId, ManagedProcess>
  - ManagedProcess：Process 引用 + 输出缓冲区 + 状态
  - 输出缓冲区：后台线程持续读取 stdout，追加到缓冲区
  - 已读偏移量：每次 status 返回增量输出（避免重复）
  - 自动清理：进程结束后保留输出一段时间，超时后清除
- [ ] shell_start 工具
  - 参数：command (string)
  - 启动进程，立即返回 processId + 初始状态
  - hitl: true
- [ ] shell_status 工具
  - 参数：processId (string)
  - 返回：状态 (running/exited) + 增量输出 + exitCode（如已结束）
  - hitl: false（只是查看）
- [ ] shell_kill 工具
  - 参数：processId (string)
  - 终止进程，返回最终输出
  - hitl: false（终止是安全操作）

### 知识点

- 后台线程持续读取进程输出
- 增量输出机制（已读偏移量）
- 进程生命周期管理
- Agent 自主决策能力

### 验收标准

- shell_start 启动 `ping -n 10 127.0.0.1`，立即返回 processId
- shell_status 多次调用，每次返回新增的输出行
- 进程结束后 shell_status 返回 exited + exitCode
- shell_kill 能终止正在运行的进程
- 综合测试：Agent 能用 shell_start 启动命令，通过多次 shell_status 观察输出，自行判断结果

---

## P2-05：ToolDispatcher 调度器

`feat(tools): [P2-05] ToolDispatcher 调度器`

### 任务清单

- [ ] ToolDispatcher 组件
  - dispatch(toolName, arguments)：执行工具
  - 从 ToolRegistry 获取工具
  - 参数校验（可选：JSON Schema 校验）
- [ ] 权限检查（预留）
  - allowedTools 白名单参数
  - 不在白名单内拒绝执行
- [ ] 错误封装
  - 工具不存在
  - 参数校验失败
  - 执行异常
- [ ] 返回统一 ToolResult

### 知识点

- 调度器模式
- 参数校验策略
- 错误处理与封装

### 验收标准

- 正确路由到对应工具并执行
- 未知工具返回错误
- 白名单外工具拒绝执行

---

## P2-06：AgentRuntime ReAct 单步

`feat(runtime): [P2-06] AgentRuntime ReAct 单步`

### 任务清单

- [ ] AgentRuntime 组件（替代原 AgentRunHandler 中的直接调用）
- [ ] ContextBuilder 增强
  - 注入 tools 定义到 LlmRequest
  - 构建包含工具的请求
- [ ] 单步执行流程
  1. 构建 context（history + tools）
  2. 调用 LLM
  3. 如果返回 tool_calls → 调用 ToolDispatcher
  4. 将工具结果作为 tool message 追加
  5. 再次调用 LLM 获取最终回复
- [ ] 修改 AgentRunHandler 使用 AgentRuntime

### 知识点

- ReAct 循环核心思想
- Tool message 格式（role: tool）
- 上下文累积

### 验收标准

- 给一个需要工具的任务（如"读取 README.md 的内容"）
- Agent 能自动调用 read_file 工具
- 最终回复包含文件内容

---

## P2-07：ReAct 多步循环与防护

`feat(runtime): [P2-07] ReAct 多步循环与防护`

### 任务清单

- [ ] ReAct 循环实现
  ```
  while (steps < maxSteps) {
      response = llm.call(context)
      if (no tool_calls) break  // 最终回复
      for each tool_call:
          result = dispatcher.dispatch(tool_call)
          context.addToolResult(result)
      steps++
  }
  ```
- [ ] 配置项
  - agent.max-steps: 最大循环次数（默认 10）
  - agent.step-timeout: 单步超时（默认 60s）
- [ ] 循环终止条件
  - LLM 返回无 tool_calls（正常结束）
  - 达到 max_steps（强制结束，返回中间状态）
  - 超时或错误
- [ ] 步骤日志记录

### 知识点

- 循环控制与终止条件
- 超时处理
- 防止无限循环

### 验收标准

- 给一个需要 2+ 步工具调用的任务
- Agent 能完成多轮 Think → Act → Observe
- 达到 max_steps 时优雅终止

---

## P2-08：tool.call / tool.result 事件

`feat(gateway): [P2-08] tool.call / tool.result 事件`

### 任务清单

- [ ] AgentEvent 新增事件类型
  - TOOL_CALL：发起工具调用
  - TOOL_RESULT：工具执行结果
- [ ] 事件数据结构
  - tool.call: { toolName, arguments, callId }
  - tool.result: { callId, success, content }
- [ ] AgentRuntime 中发布事件
  - 调用工具前发布 tool.call
  - 工具返回后发布 tool.result
- [ ] RpcEvent 序列化

### 知识点

- 事件驱动架构
- 可观测性设计
- 前后端事件协议

### 验收标准

- 执行带工具调用的任务
- WS 依次收到：lifecycle.start → tool.call → tool.result → assistant.delta → lifecycle.end
- 事件数据完整可用

---

## P2-09：HITL 确认机制

`feat(tools): [P2-09] HITL 确认机制`

### 任务清单

- [ ] AgentEvent 新增
  - TOOL_CONFIRM_REQUEST：请求确认
- [ ] HitlManager 组件
  - requestConfirmation(runId, callId, toolName, arguments): Mono<HitlDecision>
  - 内部使用 Mono.create + Sinks.One 实现等待
  - 存储 pending confirmations: Map<callId, Sinks.One>
- [ ] tool.confirm RPC Handler
  - 参数：callId, decision (approve/reject/modify), modifiedArgs?
  - 完成对应的 Sinks.One
- [ ] AgentRuntime 集成
  - 执行工具前检查 hitl 标记
  - 需要确认时调用 HitlManager.requestConfirmation()
  - 等待用户决策
- [ ] 超时处理（如 5 分钟无响应自动 reject）

### 知识点

- Reactor Mono.create 模式
- Sinks.One 单值发射
- 异步等待与超时

### 验收标准

- 调用 write_file 时收到 tool.confirm_request 事件
- 发送 tool.confirm approve 后工具执行
- 发送 tool.confirm reject 后工具跳过，Agent 收到拒绝信息
- 超时后自动 reject

---

## P2-10：Vue 工具调用可视化

`feat(ui): [P2-10] Vue 工具调用可视化`

### 任务清单

- [ ] 工具调用展示组件
  - 显示工具名称、参数
  - 显示执行结果（成功/失败）
  - 折叠/展开详情
- [ ] HITL 确认 UI
  - 收到 tool.confirm_request 显示确认弹窗/卡片
  - Approve / Reject 按钮
  - 可选：参数编辑（Modify）
- [ ] 消息流集成
  - tool.call 事件插入消息流
  - tool.result 更新对应卡片
  - 等待确认时显示 pending 状态
- [ ] 样式：保持黑白简约风格

### 知识点

- Vue 组件通信
- 事件驱动 UI 更新
- 异步状态管理

### 验收标准

- 工具调用过程可视化展示
- HITL 确认流程完整可用
- 整体交互流畅，状态清晰

---

## Phase 2 完成标志

- [ ] 4 个内置工具可用（read_file / write_file / http_get / shell）
- [ ] ReAct 循环支持多步工具调用
- [ ] HITL 确认机制完整（请求 → 等待 → 响应）
- [ ] 工具调用过程通过事件推送给前端
- [ ] Vue UI 可视化工具调用流程
- [ ] max_steps / timeout 防护生效

## 下一步

Phase 2 完成后，进入 Phase 3：Skills 系统
