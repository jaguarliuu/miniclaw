# P2-07 ReAct 多步循环与防护 实现计划

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** 实现完整的 ReAct 多步循环，支持多重终止条件（收口/超时/取消/maxSteps）、取消机制、Hook 扩展点。

**Architecture:**
- 引入 `RunContext` 封装运行时状态和取消信号
- 引入 `CancellationManager` 管理取消请求
- 重构 `AgentRuntime.executeLoop()` 支持多步循环
- 新增 `agent.cancel` RPC Handler 支持外部取消
- 新增事件类型 `step.completed` 跟踪循环进度

**Tech Stack:** Spring Boot, Reactor, ConcurrentHashMap (取消注册表)

---

## 核心设计

### 终止条件矩阵

| 触发条件 | 检查位置 | 结果状态 | 说明 |
|----------|----------|----------|------|
| 模型收口（无 tool_calls） | 循环内 | DONE | 正常结束 |
| 达到 maxSteps | 循环条件 | DONE + 警告 | 防护机制 |
| 循环超时 | 循环开始 | ERROR | runTimeoutSeconds |
| 单步超时 | LLM 调用 | ERROR | stepTimeoutSeconds |
| 外部取消 | 循环开始 | CANCELED | CancellationManager |
| 工具执行失败 | 工具调用后 | 继续循环 | 错误信息追加到上下文 |

### 架构图

```
┌─────────────────────────────────────────────────────────┐
│  agent.run RPC                 agent.cancel RPC         │
└──────────┬─────────────────────────────┬────────────────┘
           │                             │
           ▼                             ▼
┌─────────────────────┐      ┌─────────────────────────┐
│  AgentRunHandler    │      │  AgentCancelHandler     │
│  - prepareRun()     │      │  - requestCancel(runId) │
│  - executeRun()     │      └───────────┬─────────────┘
└──────────┬──────────┘                  │
           │                             │
           ▼                             ▼
┌─────────────────────────────────────────────────────────┐
│                    CancellationManager                   │
│  - cancelFlags: Map<runId, AtomicBoolean>               │
│  - requestCancel(runId)                                 │
│  - isCancelled(runId)                                   │
│  - clearCancellation(runId)                             │
└─────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────┐
│                      RunContext                          │
│  - runId, connectionId, sessionId                       │
│  - startTime: Instant                                   │
│  - config: LoopConfig (maxSteps, timeouts)             │
│  - cancellationManager: CancellationManager             │
│  - isAborted(): boolean                                 │
│  - isTimedOut(): boolean                                │
└─────────────────────────────────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────────────────────┐
│              AgentRuntime.executeLoop()                  │
│                                                         │
│  step = 0                                               │
│  while (step < maxSteps) {                              │
│      if (context.isAborted()) → CANCELED                │
│      if (context.isTimedOut()) → ERROR                  │
│                                                         │
│      result = streamLlmCall(...)                        │
│                                                         │
│      if (!result.hasToolCalls()) {                      │
│          → 正常收口, break                               │
│      }                                                  │
│                                                         │
│      for each toolCall:                                 │
│          // Hook: beforeToolCall (预留给 HITL)          │
│          toolResult = dispatcher.dispatch(...)          │
│          // Hook: afterToolCall                         │
│          messages.add(toolResult)                       │
│                                                         │
│      step++                                             │
│      eventBus.publish(step.completed)                   │
│  }                                                      │
│                                                         │
│  if (step >= maxSteps) → 警告日志                        │
└─────────────────────────────────────────────────────────┘
```

---

## Task 1: LoopConfig 配置类

**Files:**
- Create: `src/main/java/com/jaguarliu/ai/runtime/LoopConfig.java`
- Modify: `src/main/resources/application.yml`

**Step 1: 创建 LoopConfig 配置类**

```java
package com.jaguarliu.ai.runtime;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

/**
 * ReAct 循环配置
 */
@Data
@Component
@ConfigurationProperties(prefix = "agent.loop")
public class LoopConfig {

    /**
     * 最大循环步数（防止无限循环）
     */
    private int maxSteps = 10;

    /**
     * 整个循环的超时时间（秒）
     */
    private long runTimeoutSeconds = 300;

    /**
     * 单步超时时间（秒），包含 LLM 调用 + 工具执行
     */
    private long stepTimeoutSeconds = 120;
}
```

**Step 2: 更新 application.yml 添加配置**

在 `agent:` 下添加：

```yaml
agent:
  system-prompt: |
    你是一个有帮助的 AI 助手。请用中文回答用户的问题。
    回答要简洁、准确、有条理。
  max-history-messages: 20
  loop:
    max-steps: 10
    run-timeout-seconds: 300
    step-timeout-seconds: 120
```

**Step 3: 验证配置加载**

启动应用，检查日志确认配置被正确加载。

**Step 4: Commit**

```bash
git add src/main/java/com/jaguarliu/ai/runtime/LoopConfig.java src/main/resources/application.yml
git commit -m "feat(runtime): [P2-07] LoopConfig 循环配置"
```

---

## Task 2: CancellationManager 取消管理器

**Files:**
- Create: `src/main/java/com/jaguarliu/ai/runtime/CancellationManager.java`

**Step 1: 创建 CancellationManager**

```java
package com.jaguarliu.ai.runtime;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * 取消管理器
 * 管理 run 的取消请求，支持外部取消正在执行的 ReAct 循环
 */
@Slf4j
@Component
public class CancellationManager {

    /**
     * 取消标记注册表：runId -> 是否已取消
     */
    private final Map<String, AtomicBoolean> cancelFlags = new ConcurrentHashMap<>();

    /**
     * 请求取消指定的 run
     *
     * @param runId 运行 ID
     */
    public void requestCancel(String runId) {
        cancelFlags.computeIfAbsent(runId, k -> new AtomicBoolean(false)).set(true);
        log.info("Cancellation requested: runId={}", runId);
    }

    /**
     * 检查 run 是否已被取消
     *
     * @param runId 运行 ID
     * @return 是否已取消
     */
    public boolean isCancelled(String runId) {
        AtomicBoolean flag = cancelFlags.get(runId);
        return flag != null && flag.get();
    }

    /**
     * 清理取消标记（run 结束后调用）
     *
     * @param runId 运行 ID
     */
    public void clearCancellation(String runId) {
        cancelFlags.remove(runId);
        log.debug("Cancellation cleared: runId={}", runId);
    }

    /**
     * 注册 run（开始执行时调用）
     *
     * @param runId 运行 ID
     */
    public void register(String runId) {
        cancelFlags.put(runId, new AtomicBoolean(false));
        log.debug("Run registered for cancellation tracking: runId={}", runId);
    }
}
```

**Step 2: 验证编译**

```bash
./mvnw compile -q
```

**Step 3: Commit**

```bash
git add src/main/java/com/jaguarliu/ai/runtime/CancellationManager.java
git commit -m "feat(runtime): [P2-07] CancellationManager 取消管理器"
```

---

## Task 3: RunContext 运行上下文

**Files:**
- Create: `src/main/java/com/jaguarliu/ai/runtime/RunContext.java`

**Step 1: 创建 RunContext**

```java
package com.jaguarliu.ai.runtime;

import lombok.Builder;
import lombok.Getter;

import java.time.Duration;
import java.time.Instant;

/**
 * ReAct 循环运行上下文
 * 封装运行时状态、配置和控制信号
 */
@Getter
@Builder
public class RunContext {

    /**
     * 运行 ID
     */
    private final String runId;

    /**
     * 连接 ID（用于事件推送）
     */
    private final String connectionId;

    /**
     * 会话 ID
     */
    private final String sessionId;

    /**
     * 循环开始时间
     */
    private final Instant startTime;

    /**
     * 循环配置
     */
    private final LoopConfig config;

    /**
     * 取消管理器
     */
    private final CancellationManager cancellationManager;

    /**
     * 当前步数
     */
    private int currentStep;

    /**
     * 检查是否已被取消
     */
    public boolean isAborted() {
        return cancellationManager.isCancelled(runId);
    }

    /**
     * 检查是否已超时（整个循环）
     */
    public boolean isTimedOut() {
        long elapsedSeconds = Duration.between(startTime, Instant.now()).getSeconds();
        return elapsedSeconds > config.getRunTimeoutSeconds();
    }

    /**
     * 检查是否达到最大步数
     */
    public boolean isMaxStepsReached() {
        return currentStep >= config.getMaxSteps();
    }

    /**
     * 增加步数
     */
    public void incrementStep() {
        this.currentStep++;
    }

    /**
     * 获取已用时间（秒）
     */
    public long getElapsedSeconds() {
        return Duration.between(startTime, Instant.now()).getSeconds();
    }

    /**
     * 创建上下文
     */
    public static RunContext create(
            String runId,
            String connectionId,
            String sessionId,
            LoopConfig config,
            CancellationManager cancellationManager) {
        return RunContext.builder()
                .runId(runId)
                .connectionId(connectionId)
                .sessionId(sessionId)
                .startTime(Instant.now())
                .config(config)
                .cancellationManager(cancellationManager)
                .currentStep(0)
                .build();
    }
}
```

**Step 2: 验证编译**

```bash
./mvnw compile -q
```

**Step 3: Commit**

```bash
git add src/main/java/com/jaguarliu/ai/runtime/RunContext.java
git commit -m "feat(runtime): [P2-07] RunContext 运行上下文"
```

---

## Task 4: 新增事件类型 step.completed

**Files:**
- Modify: `src/main/java/com/jaguarliu/ai/gateway/events/AgentEvent.java`

**Step 1: 添加 STEP_COMPLETED 事件类型**

在 `EventType` 枚举中添加：

```java
STEP_COMPLETED("step.completed"),
```

**Step 2: 添加 StepData 内部类**

```java
@Data
@AllArgsConstructor
public static class StepData {
    private int step;
    private int maxSteps;
    private long elapsedSeconds;
}
```

**Step 3: 添加工厂方法**

```java
/**
 * 创建 step.completed 事件
 */
public static AgentEvent stepCompleted(String connectionId, String runId, int step, int maxSteps, long elapsedSeconds) {
    return AgentEvent.builder()
            .type(EventType.STEP_COMPLETED)
            .connectionId(connectionId)
            .runId(runId)
            .data(new StepData(step, maxSteps, elapsedSeconds))
            .build();
}
```

**Step 4: 验证编译**

```bash
./mvnw compile -q
```

**Step 5: Commit**

```bash
git add src/main/java/com/jaguarliu/ai/gateway/events/AgentEvent.java
git commit -m "feat(events): [P2-07] step.completed 事件类型"
```

---

## Task 5: 重构 AgentRuntime 支持多步循环

**Files:**
- Modify: `src/main/java/com/jaguarliu/ai/runtime/AgentRuntime.java`

**Step 1: 添加依赖注入**

添加 `LoopConfig` 和 `CancellationManager` 依赖：

```java
private final LlmClient llmClient;
private final ToolRegistry toolRegistry;
private final ToolDispatcher toolDispatcher;
private final EventBus eventBus;
private final LoopConfig loopConfig;
private final CancellationManager cancellationManager;
```

**Step 2: 新增 executeLoop 方法（多步循环）**

```java
/**
 * 执行 ReAct 多步循环
 *
 * @param connectionId 连接 ID
 * @param runId        运行 ID
 * @param sessionId    会话 ID
 * @param messages     初始消息列表（会被修改）
 * @return 最终回复内容
 * @throws CancellationException 如果被取消
 * @throws TimeoutException      如果超时
 */
public String executeLoop(String connectionId, String runId, String sessionId,
                          List<LlmRequest.Message> messages) {
    // 1. 创建运行上下文
    RunContext context = RunContext.create(runId, connectionId, sessionId,
            loopConfig, cancellationManager);

    // 2. 注册到取消管理器
    cancellationManager.register(runId);

    try {
        return doExecuteLoop(context, messages);
    } finally {
        // 3. 清理取消标记
        cancellationManager.clearCancellation(runId);
    }
}

/**
 * 执行循环核心逻辑
 */
private String doExecuteLoop(RunContext context, List<LlmRequest.Message> messages) {
    log.info("Starting ReAct loop: runId={}, maxSteps={}, timeout={}s",
            context.getRunId(), context.getConfig().getMaxSteps(),
            context.getConfig().getRunTimeoutSeconds());

    String lastContent = "";

    while (!context.isMaxStepsReached()) {
        // 检查取消
        if (context.isAborted()) {
            log.info("Loop aborted by cancellation: runId={}, step={}",
                    context.getRunId(), context.getCurrentStep());
            throw new CancellationException("Run cancelled by user");
        }

        // 检查超时
        if (context.isTimedOut()) {
            log.warn("Loop timed out: runId={}, elapsed={}s, limit={}s",
                    context.getRunId(), context.getElapsedSeconds(),
                    context.getConfig().getRunTimeoutSeconds());
            throw new TimeoutException("ReAct loop timeout after " +
                    context.getElapsedSeconds() + " seconds");
        }

        // 执行单步
        StepResult result = executeSingleStep(context, messages);
        lastContent = result.content();

        // 如果没有工具调用，正常结束
        if (!result.hasToolCalls()) {
            messages.add(LlmRequest.Message.assistant(result.content()));
            log.info("Loop completed normally: runId={}, steps={}",
                    context.getRunId(), context.getCurrentStep());
            return result.content();
        }

        // 有工具调用，执行工具
        messages.add(LlmRequest.Message.assistantWithToolCalls(result.toolCalls()));

        for (ToolCall toolCall : result.toolCalls()) {
            // Hook 点：beforeToolCall（预留给 HITL）
            ToolResult toolResult = executeToolCall(context, toolCall);
            // Hook 点：afterToolCall
            messages.add(LlmRequest.Message.toolResult(toolCall.getId(), toolResult.getContent()));
        }

        // 增加步数并发布事件
        context.incrementStep();
        eventBus.publish(AgentEvent.stepCompleted(
                context.getConnectionId(),
                context.getRunId(),
                context.getCurrentStep(),
                context.getConfig().getMaxSteps(),
                context.getElapsedSeconds()));

        log.debug("Step completed: runId={}, step={}/{}",
                context.getRunId(), context.getCurrentStep(),
                context.getConfig().getMaxSteps());
    }

    // 达到最大步数
    log.warn("Loop reached max steps: runId={}, maxSteps={}",
            context.getRunId(), context.getConfig().getMaxSteps());

    // 最后一次调用 LLM 获取总结
    StepResult finalResult = executeSingleStep(context, messages);
    messages.add(LlmRequest.Message.assistant(finalResult.content()));

    return finalResult.content();
}

/**
 * 执行单步（一次 LLM 调用）
 */
private StepResult executeSingleStep(RunContext context, List<LlmRequest.Message> messages) {
    LlmRequest request = LlmRequest.builder()
            .messages(messages)
            .tools(toolRegistry.toOpenAiTools())
            .toolChoice("auto")
            .build();

    return streamLlmCall(context.getConnectionId(), context.getRunId(), request);
}

/**
 * 执行单个工具调用（使用 RunContext）
 */
private ToolResult executeToolCall(RunContext context, ToolCall toolCall) {
    String toolName = toolCall.getName();
    String argumentsJson = toolCall.getArguments();

    log.info("Executing tool: name={}, callId={}, runId={}, step={}",
            toolName, toolCall.getId(), context.getRunId(), context.getCurrentStep());

    Map<String, Object> arguments = parseArguments(argumentsJson);
    ToolResult result = toolDispatcher.dispatch(toolName, arguments).block();

    if (result == null) {
        result = ToolResult.error("Tool execution returned null");
    }

    log.info("Tool executed: name={}, success={}, runId={}",
            toolName, result.isSuccess(), context.getRunId());
    return result;
}
```

**Step 3: 添加异常类导入**

```java
import java.util.concurrent.CancellationException;
import java.util.concurrent.TimeoutException;
```

**Step 4: 保留原有 executeStep 方法（向后兼容）**

将原有 `executeStep` 标记为 `@Deprecated` 或保持原样作为简化版本。

**Step 5: 验证编译**

```bash
./mvnw compile -q
```

**Step 6: Commit**

```bash
git add src/main/java/com/jaguarliu/ai/runtime/AgentRuntime.java
git commit -m "feat(runtime): [P2-07] AgentRuntime 多步循环实现"
```

---

## Task 6: AgentCancelHandler 取消处理器

**Files:**
- Create: `src/main/java/com/jaguarliu/ai/gateway/rpc/handler/AgentCancelHandler.java`

**Step 1: 创建 AgentCancelHandler**

```java
package com.jaguarliu.ai.gateway.rpc.handler;

import com.jaguarliu.ai.gateway.rpc.RpcHandler;
import com.jaguarliu.ai.gateway.rpc.model.RpcRequest;
import com.jaguarliu.ai.gateway.rpc.model.RpcResponse;
import com.jaguarliu.ai.runtime.CancellationManager;
import com.jaguarliu.ai.session.RunService;
import com.jaguarliu.ai.session.RunStatus;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import java.util.Map;

/**
 * agent.cancel 处理器
 * 取消正在执行的 run
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class AgentCancelHandler implements RpcHandler {

    private final CancellationManager cancellationManager;
    private final RunService runService;

    @Override
    public String getMethod() {
        return "agent.cancel";
    }

    @Override
    public Mono<RpcResponse> handle(String connectionId, RpcRequest request) {
        String runId = extractRunId(request.getPayload());

        if (runId == null || runId.isBlank()) {
            return Mono.just(RpcResponse.error(request.getId(), "INVALID_PARAMS", "Missing runId"));
        }

        // 检查 run 是否存在
        var runOpt = runService.get(runId);
        if (runOpt.isEmpty()) {
            return Mono.just(RpcResponse.error(request.getId(), "NOT_FOUND", "Run not found: " + runId));
        }

        // 检查 run 是否可以取消
        var run = runOpt.get();
        RunStatus currentStatus = RunStatus.fromValue(run.getStatus());
        if (!currentStatus.canTransitionTo(RunStatus.CANCELED)) {
            return Mono.just(RpcResponse.error(request.getId(), "INVALID_STATE",
                    "Cannot cancel run in status: " + currentStatus.getValue()));
        }

        // 请求取消
        cancellationManager.requestCancel(runId);
        log.info("Cancel requested: runId={}, connectionId={}", runId, connectionId);

        return Mono.just(RpcResponse.success(request.getId(), Map.of(
                "runId", runId,
                "cancelled", true,
                "message", "Cancellation requested"
        )));
    }

    private String extractRunId(Object payload) {
        if (payload instanceof Map) {
            Object id = ((Map<?, ?>) payload).get("runId");
            return id != null ? id.toString() : null;
        }
        return null;
    }
}
```

**Step 2: 验证编译**

```bash
./mvnw compile -q
```

**Step 3: Commit**

```bash
git add src/main/java/com/jaguarliu/ai/gateway/rpc/handler/AgentCancelHandler.java
git commit -m "feat(gateway): [P2-07] agent.cancel RPC 处理器"
```

---

## Task 7: 更新 AgentRunHandler 使用 executeLoop

**Files:**
- Modify: `src/main/java/com/jaguarliu/ai/gateway/rpc/handler/AgentRunHandler.java`

**Step 1: 修改 executeRun 方法**

将 `agentRuntime.executeStep(...)` 改为 `agentRuntime.executeLoop(...)`：

```java
// 原代码：
String response = agentRuntime.executeStep(connectionId, runId, messages);

// 改为：
String response = agentRuntime.executeLoop(connectionId, runId, sessionId, messages);
```

**Step 2: 处理取消异常**

在 catch 块中添加 `CancellationException` 处理：

```java
} catch (java.util.concurrent.CancellationException e) {
    log.info("Run cancelled: id={}", runId);
    try {
        runService.updateStatus(runId, RunStatus.CANCELED);
    } catch (Exception ignored) {}
    eventBus.publish(AgentEvent.lifecycleError(connectionId, runId, "Cancelled by user"));
} catch (java.util.concurrent.TimeoutException e) {
    log.warn("Run timed out: id={}", runId);
    try {
        runService.updateStatus(runId, RunStatus.ERROR);
    } catch (Exception ignored) {}
    eventBus.publish(AgentEvent.lifecycleError(connectionId, runId, e.getMessage()));
} catch (Exception e) {
    // 原有的异常处理
}
```

**Step 3: 验证编译**

```bash
./mvnw compile -q
```

**Step 4: Commit**

```bash
git add src/main/java/com/jaguarliu/ai/gateway/rpc/handler/AgentRunHandler.java
git commit -m "feat(gateway): [P2-07] AgentRunHandler 使用多步循环"
```

---

## Task 8: 集成测试验证

**验证场景：**

### 场景 1：多步工具调用

```javascript
// 需要多次工具调用的任务
ws.send(JSON.stringify({
  type: "request",
  id: "multi-step",
  method: "agent.run",
  payload: {
    prompt: "先读取 test.txt 的内容，然后把内容写入到 test2.txt 文件中"
  }
}))

// 预期：
// 1. lifecycle.start
// 2. LLM 调用 read_file
// 3. step.completed (step=1)
// 4. LLM 调用 write_file
// 5. step.completed (step=2)
// 6. LLM 输出最终回复
// 7. lifecycle.end
```

### 场景 2：取消正在执行的任务

```javascript
// 启动一个长时间任务
ws.send(JSON.stringify({
  type: "request",
  id: "long-task",
  method: "agent.run",
  payload: {
    prompt: "执行 ping -n 100 127.0.0.1 命令"
  }
}))

// 等待 lifecycle.start 后取消
ws.send(JSON.stringify({
  type: "request",
  id: "cancel-1",
  method: "agent.cancel",
  payload: {
    runId: "<从上一个响应获取的 runId>"
  }
}))

// 预期：
// 1. 收到取消确认响应
// 2. lifecycle.error (message: "Cancelled by user")
```

### 场景 3：普通对话（无工具调用）

```javascript
ws.send(JSON.stringify({
  type: "request",
  id: "simple",
  method: "agent.run",
  payload: {
    prompt: "1+1等于多少"
  }
}))

// 预期：step=0，直接返回结果，不触发 step.completed
```

**Step: Commit 最终验证**

```bash
git add -A
git commit -m "feat(runtime): [P2-07] ReAct 多步循环与防护 - 完成"
```

---

## 文件变更汇总

| 操作 | 文件路径 |
|------|----------|
| Create | `src/main/java/com/jaguarliu/ai/runtime/LoopConfig.java` |
| Create | `src/main/java/com/jaguarliu/ai/runtime/CancellationManager.java` |
| Create | `src/main/java/com/jaguarliu/ai/runtime/RunContext.java` |
| Create | `src/main/java/com/jaguarliu/ai/gateway/rpc/handler/AgentCancelHandler.java` |
| Modify | `src/main/java/com/jaguarliu/ai/runtime/AgentRuntime.java` |
| Modify | `src/main/java/com/jaguarliu/ai/gateway/rpc/handler/AgentRunHandler.java` |
| Modify | `src/main/java/com/jaguarliu/ai/gateway/events/AgentEvent.java` |
| Modify | `src/main/resources/application.yml` |

---

## 验收标准

- [ ] 多步工具调用能正常完成（2+ 步）
- [ ] `step.completed` 事件正确推送
- [ ] `agent.cancel` 能取消正在执行的任务
- [ ] 超时后正确终止并返回 ERROR 状态
- [ ] 达到 maxSteps 后优雅终止
- [ ] 普通对话（无工具）正常工作
