# MiniClaw Phase 1 实施计划

> 目标：WebSocket 连接 → 发送消息 → LLM 流式响应 → 多轮对话 → Vue UI 展示

## 概览

| 编号 | 模块 | 主题 | 预估时间 |
|------|------|------|----------|
| P1-01 | infra | Docker Compose + DB schema + JPA 基础 | 30-60 min |
| P1-02 | gateway | WebSocket 配置与连接管理 | 30-60 min |
| P1-03 | gateway | JSON-RPC 消息模型与 RPC Router | 30-60 min |
| P1-04 | session | Session 管理（创建/列表/切换） | 30-60 min |
| P1-05 | llm | LLM Client 基础实现 | 30-60 min |
| P1-06 | llm | SSE 流式解析 | 30-60 min |
| P1-07 | session | Run 状态机与持久化 | 30-60 min |
| P1-08 | session | SessionLane 串行队列 | 30-60 min |
| P1-09 | gateway | EventBus 事件推送 | 30-60 min |
| P1-10 | runtime | 串联主链路 | 30-60 min |
| P1-11 | session | Messages 持久化与多轮对话 | 30-60 min |
| P1-12 | web | Vue 基础对话页面 | 30-60 min |

## Git Commit 规范

格式：`<type>(<scope>): [P1-XX] <description>`

示例：
- `chore(infra): [P1-01] Docker Compose + DB schema + JPA 基础`
- `feat(gateway): [P1-02] WebSocket 配置与连接管理`
- `feat(llm): [P1-05] LLM Client 基础实现`

## 前置条件

- Spring Boot 3 + WebFlux 项目骨架（预提供）
- Vue 项目骨架（预提供）
- Docker Desktop 已安装
- 国产大模型 API Key 或本地 Ollama

---

## P1-01：Docker Compose + DB schema + JPA 基础

`chore(infra): [P1-01] Docker Compose + DB schema + JPA 基础`

### 任务清单

- [ ] Docker Compose 配置（PostgreSQL + pgvector 扩展）
- [ ] Flyway 初始化迁移脚本
  - sessions 表：id, name, created_at, updated_at
  - runs 表：id, session_id, status, prompt, created_at, updated_at
  - messages 表：id, session_id, run_id, role, content, created_at
- [ ] JPA Entity 定义：Session, Run, Message
- [ ] Spring Data JPA Repository 接口
- [ ] application.yml 数据源配置

### 知识点

- Docker Compose 多服务编排
- PostgreSQL + pgvector 扩展安装
- Flyway 数据库迁移机制
- JPA Entity 映射与 Repository 模式

### 验收标准

- `docker-compose up -d` 启动 PostgreSQL 成功
- Spring Boot 应用启动无报错
- 数据库中自动创建 sessions / runs / messages 三张表

---

## P1-02：WebSocket 配置与连接管理

`feat(gateway): [P1-02] WebSocket 配置与连接管理`

### 任务清单

- [ ] WebFlux WebSocketHandler 配置类
- [ ] WebSocket 路由配置（如 `/ws`）
- [ ] ConnectionManager 组件
  - 维护 connectionId → WebSocketSession 映射
  - 连接建立时注册
  - 连接断开时移除
- [ ] 连接生命周期日志（连接/断开）

### 知识点

- WebFlux 响应式 WebSocket 编程模型
- WebSocketHandler 接口与实现
- 连接生命周期管理
- ConcurrentHashMap 线程安全

### 验收标准

- 浏览器控制台执行 `new WebSocket('ws://localhost:8080/ws')` 能连接成功
- 服务端打印连接建立日志
- 关闭连接后服务端打印断开日志

---

## P1-03：JSON-RPC 消息模型与 RPC Router

`feat(gateway): [P1-03] JSON-RPC 消息模型与 RPC Router`

### 任务清单

- [ ] 消息模型定义
  - RpcRequest：type, id, method, payload
  - RpcResponse：type, id, payload, error
  - RpcEvent：type, event, runId, payload
- [ ] Jackson 序列化/反序列化配置
- [ ] RpcRouter 组件
  - 注册 method → handler 映射
  - 根据 method 字段分发请求
  - 未知 method 返回错误响应
- [ ] 内置 ping handler（测试用）

### 知识点

- 自定义 RPC 协议设计
- Jackson JSON 处理
- 策略模式 / 命令模式
- WebSocket 消息收发

### 验收标准

- WS 发送 `{"type":"request","id":"1","method":"ping","payload":{}}`
- 收到 `{"type":"response","id":"1","payload":{"message":"pong"}}`
- 发送未知 method 收到错误响应

---

## P1-04：Session 管理（创建/列表/切换）

`feat(session): [P1-04] Session 管理（创建/列表/切换）`

### 任务清单

- [ ] SessionService
  - create(name)：创建新 session
  - list()：列出所有 session
  - get(id)：获取单个 session
- [ ] RPC Handler 注册
  - session.create → SessionService.create
  - session.list → SessionService.list
- [ ] Session 持久化（通过 JPA Repository）

### 知识点

- 服务层设计
- RPC Handler 注册机制
- JPA 持久化操作

### 验收标准

- WS 调用 session.create 创建 session，返回 session 信息
- WS 调用 session.list 能查到刚创建的 session
- 重启应用后，session.list 仍能查到之前的 session

---

## P1-05：LLM Client 基础实现

`feat(llm): [P1-05] LLM Client 基础实现`

### 任务清单

- [ ] LlmClient 接口定义
  ```java
  public interface LlmClient {
      LlmResponse chat(LlmRequest request);  // 同步
      Flux<LlmChunk> stream(LlmRequest request);  // 流式
  }
  ```
- [ ] LlmRequest / LlmResponse / LlmChunk 模型
- [ ] OpenAiCompatibleLlmClient 实现
  - WebClient 构建
  - 请求体组装（messages, model, temperature 等）
  - 响应解析
- [ ] 配置化：application.yml 中配置 endpoint / apiKey / model
- [ ] 先实现同步 chat() 方法

### 知识点

- OpenAI API 协议格式
- WebClient 响应式 HTTP 客户端
- 配置属性绑定（@ConfigurationProperties）
- 接口抽象与实现分离

### 验收标准

- 编写测试类，调用 chat() 方法
- 成功返回国产模型或 Ollama 的响应文本

---

## P1-06：SSE 流式解析

`feat(llm): [P1-06] SSE 流式解析`

### 任务清单

- [ ] 实现 stream() 方法，返回 Flux<LlmChunk>
- [ ] SSE 数据解析
  - 按行读取 `data: {...}`
  - JSON 解析为 LlmChunk
  - 提取 delta.content
- [ ] 处理结束标记 `data: [DONE]`
- [ ] 错误处理
  - 超时处理
  - 连接断开处理
  - 非 200 响应处理

### 知识点

- Server-Sent Events (SSE) 协议
- Reactor Flux 流式处理
- 响应式错误处理（onErrorResume, timeout）

### 验收标准

- 编写测试类，调用 stream() 方法
- 控制台逐行打印 delta 文本
- 流正常结束，无异常

---

## P1-07：Run 状态机与持久化

`feat(session): [P1-07] Run 状态机与持久化`

### 任务清单

- [ ] RunService
  - create(sessionId, prompt)：创建 run，状态为 queued
  - updateStatus(runId, status)：更新状态
  - get(runId)：查询 run
- [ ] Run 状态机：queued → running → done / error
- [ ] 状态流转校验（不允许非法跳转）
- [ ] 简单执行器
  - 调用 LlmClient.stream()
  - 收集响应内容
  - 更新状态为 done（或 error）
- [ ] RPC Handler
  - agent.run：创建 run + 执行
  - run.get：查询 run 状态

### 知识点

- 状态机设计模式
- 状态流转校验
- 服务编排

### 验收标准

- WS 发送 agent.run，返回 runId
- run.get 查询状态从 queued → running → done
- LLM 响应完整返回

---

## P1-08：SessionLane 串行队列

`feat(session): [P1-08] SessionLane 串行队列`

### 任务清单

- [ ] SessionLaneManager 组件
  - 每个 session 维护一个执行队列
  - 基于 Reactor Sinks.Many + flatMap(maxConcurrency=1) 实现串行
- [ ] run 入队逻辑
  - 入队时状态为 queued
  - 出队执行时状态变为 running
- [ ] 集成到 agent.run 流程

### 知识点

- Reactor Sinks 背压与缓冲
- flatMap concurrency 控制
- 并发与串行化

### 验收标准

- 同一 session 连续发送 3 个 agent.run
- 日志确认严格按顺序执行（run1 完成 → run2 开始 → ...）
- 不同 session 的 run 可以并行执行

---

## P1-09：EventBus 事件推送

`feat(gateway): [P1-09] EventBus 事件推送`

### 任务清单

- [ ] AgentEvent 模型
  - lifecycle.start：run 开始
  - assistant.delta：LLM 输出片段
  - lifecycle.end：run 完成
  - lifecycle.error：run 出错
- [ ] EventBus 组件
  - 基于 Sinks.Many<AgentEvent> 实现
  - publish(event)：发布事件
  - subscribe(runId)：按 runId 订阅
- [ ] Gateway 集成
  - EventBus 事件 → 封装成 RpcEvent
  - 推送到对应的 WebSocket 连接

### 知识点

- 发布-订阅模式
- Reactor Sinks.Many 多播
- 事件过滤与路由

### 验收标准

- agent.run 执行时，WS 依次收到：
  - lifecycle.start
  - assistant.delta（多个）
  - lifecycle.end
- 事件的 runId 与请求匹配

---

## P1-10：串联主链路

`feat(runtime): [P1-10] 串联主链路`

### 任务清单

- [ ] 整合完整流程
  - agent.run 请求 → 创建 run
  - SessionLane 入队
  - 出队执行：LlmClient.stream()
  - 流式结果 → EventBus 推送
  - 完成后更新 run 状态
- [ ] ContextBuilder 雏形
  - 拼接 system prompt
  - 拼接用户 prompt
- [ ] 错误处理
  - LLM 调用失败 → lifecycle.error 事件
  - run 状态设为 error

### 知识点

- 流程编排
- 响应式管道组装
- 统一错误处理

### 验收标准

- WS 发送 agent.run，完整链路跑通
- 流式收到 LLM 回复
- 异常情况（如 API Key 错误）能收到 error 事件

---

## P1-11：Messages 持久化与多轮对话

`feat(session): [P1-11] Messages 持久化与多轮对话`

### 任务清单

- [ ] Message 持久化
  - 用户消息：agent.run 时入库（role=user）
  - 助手消息：streaming 完成后拼接完整内容入库（role=assistant）
- [ ] ContextBuilder 增强
  - 查询 session 历史消息
  - 按时间顺序拼入上下文
  - 控制上下文长度（可选：简单截断）

### 知识点

- 消息持久化策略
- 上下文窗口管理
- 多轮对话状态维护

### 验收标准

- 同一 session 多轮对话，LLM 能记住之前聊过的内容
- 重启应用后，查询 session 历史消息仍在
- 新对话能基于历史继续

---

## P1-12：Vue 基础对话页面

`feat(web): [P1-12] Vue 基础对话页面`

### 任务清单

- [ ] WebSocket 连接管理
  - 建立连接
  - 断线重连
  - 心跳保活（可选）
- [ ] Session 管理 UI
  - Session 列表展示
  - 创建新 Session
  - 切换 Session
- [ ] 对话界面
  - 消息列表（用户 + 助手）
  - 流式渲染：assistant.delta 逐字追加
  - 输入框 + 发送按钮
  - 发送中状态（禁用按钮 / loading）

### 知识点

- Vue 3 Composition API
- WebSocket 客户端封装
- 流式数据渲染
- 响应式状态管理

### 验收标准

- 打开页面能看到 Session 列表
- 选择/创建 Session 后进入对话
- 发送消息，LLM 回复逐字显示
- 刷新页面，历史消息仍在

---

## Phase 1 完成标志

- [ ] Docker Compose 一键启动环境
- [ ] WebSocket 连接稳定
- [ ] 支持多 Session 管理
- [ ] 同 Session 多轮对话，LLM 有上下文记忆
- [ ] 流式输出完整展示
- [ ] 数据持久化，重启不丢失
- [ ] Vue UI 可用于演示

## 下一步

Phase 1 完成后，进入 Phase 2：ReAct + 工具系统
